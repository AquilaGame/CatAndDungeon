有些程序实现上的一些细节我大概总结了一下：

这个游戏是一个Unity制作的TRPG游戏或者说是跑团模拟器，类似于神界原罪博德之门这种，实现了里面的角色、职业、物品、天赋、法术这些系统。
本身带有运行时的地图编辑器，任何时候游戏主持人都可以通过这个编辑器操作地形，并且能实时生成寻路。此外还有自定义的法术原型系统，用户可
以在配置文档里通过输入技能描述的方式创建自己的技能。

游戏程序设计的核心有两个：***场景***和***角色***，场景这一边主要是编辑器的同步修改问题比较难，角色主要是控制器和相关功能的实现比较复杂。
角色程序的设计采用了MVC架构，其中Model对应Character这个类，用于存储和管理数据，View主要对应的是CharacterPanel和CharacterCanvas，
用于实时更新人物状态，Controler对应CharacterScript这个类（这个命名是因为它是挂在Character角色本身上的MonoBehaviour脚本）。

在所有的程序实现中，我觉得最复杂的是**法术执行链**这个部分：
**（1）技能的管理和组装**：角色数据里带有魔法书和背包，魔法书上记录着技能数据。在游戏开始的时候，系统加载用户的技能配置文档（这个配置文档是
     可以使用中文直接写的，我在另一个文档里会说明），在内存里生成当前的法术原型列表，每个法术都有两种要素构成，一种是施法元素（Element），
     另一种是施法方式，也叫领域（Field）。当用户想要学习或者修改一个技能的时候，可以打开技能修改面板，以拖拽里面元素的方式设定两种要素的强度值。
     比如拖拽一个“混沌”元素，以及一个“野兽”领域进行组合，就形成了“召唤恶魔”这个技能；拖拽一个“水源”元素和一个“移动”领域，就可以组合成“寒冰箭”。
     在用户确定了强度值之后，技能管理组件（可以认为是一个建造者模式（Builder Pattern）实现的装配器）就会从法术原型里生成这个技能的实例存储在魔法书里。
     用户在进行技能调整的时候，不同分支的强度值会影响法术的效果，比如说“火球术”这个技能，它的“火焰元素”强度高了之后对敌人造成的伤害就会相应增加，
     而“移动领域”强度高了射程和爆炸范围会增加。  
     
**（2）法术释放链**：在这个游戏中，法术的释放本质是一个“动态解释用户脚本”的过程，从设计的角度看属于命令模式。当角色需要释放一个技能的时候，会生成一段由四个
     class对象组成的施法命令，分别在流程中控制法术的目标选择、命中检定、数值生成和法术效果。因为游戏本身是交互式的，所以在法术执行的过程中，经常会出现
     需要用户实时输入的场合，比如用户使用鼠标指定一个AOE法术的范围，或者通过摇骰子决定这个技能的数值。这时就需要执行链暂时挂起等待，然后调用场景内的
     目标选择器或者骰子面板，通过委托回调的方式把法术的执行链延续下去。

**（3）法术的生效**：在法术释放的最终阶段，程序通过读取执行命令的脚本进行相应的操作。这些操作是可以叠加的，比如连续释放几次（借助法术执行链的链式结构，
     每次的释放可以独立指定目标），或是在造成伤害的同时，给对方叠Buff，并且产生吸血效果这种。如果执行器正在执行的命令是数值变动，
     会调用目标列表中对应角色的Controler进行数据修改；如果是Buff、召唤这种技能，就会从库里实例化一个新的实例。这里提到的“库”可以认为是使用工厂模式
     的各个工厂，只不过内部实现不一样：像技能这种固定数目，通过索引调用的内部存储的就采用二维数组来实现，Buff这种用户在脚本中通过字符串调用的，
     就采用反射和hash表（这里还得提一下，如果环境限定不能用反射，就得把它改成建造者模式了），召唤物这种经常要变动名称和内容的，就采用双映射列表
     （当然，采用hash表也可以，不过现在只有几十种召唤物，O(n)和O(1)的差异也不大），等等。

**（4）Buff的实现**：所有Buff都采用一个Buff抽象类来管理（不用接口是因为我需要每个Buff都有默认的方法），每个Buff都是一个派生类，通过虚函数的方式实现六个行为：
     开始附加，开始生效，回合开始，回合结束，结束生效和停止附加。这样设计的原因是，每个Buff的附加事件我们只要求发生一次，比如开始附加时造成一定伤害；
     而生效可能会生效很多次，比如说Buff带一个粒子效果，那我在Load存档的时候肯定希望Load出来的人物是带Buff特效的，所以我只要在开始生效的方法里加入粒子
     的创建，Load时候就只执行这个方法就行了。

在地图这部分，**地图编辑器**用的是二维数组去存，这个地方难点主要是在任何时候保证外面的三维地形和编辑器里的二维地形是严格对应的，还有一个是每个地块，以及地块
上可能有的树或者宝箱这些Object对象的外观都是动态生成的，具体说就是在选择地块和Object的时候可以通过面板去设置它每一个部件的材质属性，这个实现起来也比较有
挑战性。还有就是在我之前的项目里，一直在用静态的NavMesh去实现寻路，而这次要求是动态的。比如说游戏主持人这边把墙开了个缺口，角色就能自动寻路通过。
所以就去GitHub上找了比较新版的NavMeshComponent，在每次修改完地图之后就即时地去烘焙新的导航网格去保证它的实时性。
